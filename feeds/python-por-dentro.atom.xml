<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PythonClub</title><link href="http://pythonclub.com.br/" rel="alternate"></link><link href="http://pythonclub.com.br/feeds/python-por-dentro.atom.xml" rel="self"></link><id>http://pythonclub.com.br/</id><updated>2015-02-24T10:17:00-03:00</updated><entry><title>Tuplas mutantes em Python</title><link href="http://pythonclub.com.br/tuplas-mutantes-em-python.html" rel="alternate"></link><updated>2015-02-24T10:17:00-03:00</updated><author><name>Luciano Ramalho</name></author><id>tag:pythonclub.com.br,2015-02-24:tuplas-mutantes-em-python.html</id><summary type="html">&lt;p&gt;Por Luciano Ramalho, autor do livro &lt;a class="reference external" href="http://shop.oreilly.com/product/0636920032519.do"&gt;Fluent Python&lt;/a&gt; (O'Reilly, 2014)&lt;/p&gt;
&lt;blockquote&gt;
See also the original article in English: &lt;a class="reference external" href="http://radar.oreilly.com/2014/10/python-tuples-immutable-but-potentially-changing.html"&gt;http://radar.oreilly.com/2014/10/python-tuples-immutable-but-potentially-changing.html&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Tuplas em Python têm uma característica surpreendente: elas são imutáveis, mas seus valores podem mudar. Isso pode acontecer quando uma &lt;tt class="docutils literal"&gt;tuple&lt;/tt&gt; contém uma referência para qualquer objeto mutável, como uma &lt;tt class="docutils literal"&gt;list&lt;/tt&gt;. Se você precisar explicar isso a um colega iniciando com Python, um bom começo é destruir o senso comum sobre variáveis serem como caixas em que armazenamos dados.&lt;/p&gt;
&lt;p&gt;Em 1997 participei de um curso de verão sobre Java no MIT. A professora, Lynn Andrea Stein - uma premiada educadora de ciência da computação - enfatizou que a habitual metáfora de &amp;quot;variáveis como caixas&amp;quot; acaba atrapalhando o entendimento sobre variáveis de referência em linguagens OO. Variáveis em Python são como variáveis de referência em Java, portanto é melhor pensar nelas como etiquetas afixadas em objetos.&lt;/p&gt;
&lt;p&gt;Eis um exemplo inspirado no livro &lt;em&gt;Alice Através do Espelho e O Que Ela Encontrou Por Lá&lt;/em&gt;, de Lewis Carroll.&lt;/p&gt;
&lt;img alt="imagem Alice Através do Espelho e O Que Ela Encontrou Por Lá" src="http://pythonclub.com.br/images/ramalho/Tweedledum-Tweedledee_500x390.png" /&gt;
&lt;p&gt;Tweedledum e Tweedledee são gêmeos. Do livro: “Alice soube no mesmo instante qual era qual porque um deles tinha 'DUM' bordado na gola e o outro, 'DEE'”.&lt;/p&gt;
&lt;img alt="exemplo 1" src="http://pythonclub.com.br/images/ramalho/diagrams/dum-dee.png" /&gt;
&lt;p&gt;Vamos representá-los como tuplas contendo a data de nascimento e uma lista de suas habilidades:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1861-10-23&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;poesia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;fingir-luta&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dee&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1861-10-23&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;poesia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;fingir-luta&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dum&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;dee&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dum&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;dee&lt;/span&gt;
&lt;span class="bp"&gt;False&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dum&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dee&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4313018120&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4312991048&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;É claro que &lt;tt class="docutils literal"&gt;dum&lt;/tt&gt; e &lt;tt class="docutils literal"&gt;dee&lt;/tt&gt; referem-se a objetos que são iguais, mas que não são o mesmo objeto. Eles têm identidades diferentes.&lt;/p&gt;
&lt;p&gt;Agora, depois dos eventos testemunhados por Alice, Tweedledum decidiu ser um rapper, adotando o nome artístico T-Doom. Podemos expressar isso em Python dessa forma:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t_doom&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dum&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t_doom&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1861-10-23&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;poesia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;fingir-luta&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t_doom&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;dum&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t_doom&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;dum&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Então, &lt;tt class="docutils literal"&gt;t_doom&lt;/tt&gt; e &lt;tt class="docutils literal"&gt;dum&lt;/tt&gt; são iguais - mas Alice acharia tolice dizer isso, porque &lt;tt class="docutils literal"&gt;t_doom&lt;/tt&gt; e &lt;tt class="docutils literal"&gt;dum&lt;/tt&gt; referem-se à mesma pessoa: &lt;tt class="docutils literal"&gt;t_doom is dum&lt;/tt&gt;.&lt;/p&gt;
&lt;img alt="exemplo 2" src="http://pythonclub.com.br/images/ramalho/diagrams/dum-t_doom-dee.png" /&gt;
&lt;p&gt;Os nomes &lt;tt class="docutils literal"&gt;t_doom&lt;/tt&gt; e &lt;tt class="docutils literal"&gt;dum&lt;/tt&gt; são apelidos. O termo em inglês &amp;quot;alias&amp;quot; significa exatamente apelido. Gosto que os documentos oficiais do Python muitas vezes referem-se a variáveis como “nomes“. Variáveis são nomes que damos a objetos. Nomes alternativos são apelidos. Isso ajuda a tirar da nossa mente a ideia de que variáveis são como caixas. Qualquer um que pense em variáveis como caixas não consegue explicar o que vem a seguir.&lt;/p&gt;
&lt;p&gt;Depois de muito praticar, T-Doom agora é um rapper experiente. Codificando, foi isso o que aconteceu:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;skills&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t_doom&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;skills&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;rap&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t_doom&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1861-10-23&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;poesia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;fingir-luta &amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rap&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;])&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dum&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1861-10-23&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;poesia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;fingir-luta &amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rap&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;T-Doom conquistou a habilidade &lt;tt class="docutils literal"&gt;rap&lt;/tt&gt;, e também Tweedledum — óbvio, pois eles são um e o mesmo. Se &lt;tt class="docutils literal"&gt;t_doom&lt;/tt&gt; fosse uma caixa contendo dados do tipo &lt;tt class="docutils literal"&gt;str&lt;/tt&gt; e &lt;tt class="docutils literal"&gt;list&lt;/tt&gt;, como você poderia explicar que uma inclusão à lista &lt;tt class="docutils literal"&gt;t_doom&lt;/tt&gt; também altera a lista na caixa &lt;tt class="docutils literal"&gt;dum&lt;/tt&gt;?  Contudo, é perfeitamente plausível se você entende variáveis como etiquetas.&lt;/p&gt;
&lt;p&gt;A analogia da etiqueta é muito melhor porque apelidos são explicados mais facilmente como um objeto com duas ou mais etiquetas. No exemplo, &lt;tt class="docutils literal"&gt;t_doom[1]&lt;/tt&gt; e &lt;tt class="docutils literal"&gt;skills&lt;/tt&gt; são dois nomes dados ao mesmo objeto da lista, da mesma forma que &lt;tt class="docutils literal"&gt;dum&lt;/tt&gt; e &lt;tt class="docutils literal"&gt;t_doom&lt;/tt&gt; são dois nomes dados ao mesmo objeto da tupla.&lt;/p&gt;
&lt;p&gt;Abaixo está uma ilustração alternativa dos objetos que representam Tweedledum. Esta figura enfatiza o fato de a tupla armazenar referências a objetos, e não os objetos em si.&lt;/p&gt;
&lt;img alt="exemplo 3" src="http://pythonclub.com.br/images/ramalho/diagrams/dum-skills-references.png" /&gt;
&lt;p&gt;O que é imutável é o conteúdo físico de uma tupla, que armazena apenas referências a objetos. O valor da lista referenciado por &lt;tt class="docutils literal"&gt;dum[1]&lt;/tt&gt; mudou, mas a identidade da lista referenciada pela tupla permanece a mesma. Uma tupla não tem meios de prevenir mudanças nos valores de seus itens, que são objetos independentes e podem ser encontrados através de referências fora da tupla, como o nome &lt;tt class="docutils literal"&gt;skills&lt;/tt&gt; que nós usamos anteriormente. Listas e outros objetos imutáveis dentro de tuplas podem ser alterados, mas suas identidades serão sempre as mesmas.&lt;/p&gt;
&lt;p&gt;Isso enfatiza a diferença entre os conceitos de identidade e valor, descritos em &lt;em&gt;Python Language Reference&lt;/em&gt;, no capítulo &lt;a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types"&gt;Data model&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
Cada objeto tem uma identidade, um tipo e um valor. A identidade de um objeto nunca muda, uma vez que tenha sido criado; você pode pensar como se fosse o endereço do objeto na memória. O operador &lt;tt class="docutils literal"&gt;is&lt;/tt&gt; compara a identidade de dois objetos; a função &lt;tt class="docutils literal"&gt;id()&lt;/tt&gt; retorna um inteiro representando a sua identidade.&lt;/blockquote&gt;
&lt;p&gt;Após &lt;tt class="docutils literal"&gt;dum&lt;/tt&gt; tornar-se um rapper, os irmãos gêmeos não são mais iguais:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;dum&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;dee&lt;/span&gt;
&lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Temos aqui duas tuplas que foram criadas iguais, mas agora elas são diferentes.&lt;/p&gt;
&lt;p&gt;O outro tipo interno de coleção imutável em Python, &lt;tt class="docutils literal"&gt;frozenset&lt;/tt&gt;, não sofre do problema de ser imutável mas com possibilidade de mudar seus valores. Isso ocorre porque um &lt;tt class="docutils literal"&gt;frozenset&lt;/tt&gt; (ou um &lt;tt class="docutils literal"&gt;set&lt;/tt&gt; simples, nesse sentido) pode apenas conter referências a objetos &lt;tt class="docutils literal"&gt;hashable&lt;/tt&gt; (objetos que podem ser usados como chave em um dicionário), e o valor destes objetos, por definição, nunca pode mudar.&lt;/p&gt;
&lt;p&gt;Tuplas são comumente usadas como chaves para objetos &lt;tt class="docutils literal"&gt;dict&lt;/tt&gt;, e precisam ser &lt;tt class="docutils literal"&gt;hashable&lt;/tt&gt; - assim como os elementos de um conjunto. Então, as tuplas são &lt;tt class="docutils literal"&gt;hashable&lt;/tt&gt; ou não? A resposta certa é &lt;strong&gt;algumas&lt;/strong&gt; tuplas são. O valor de uma tupla contendo um objeto mutável pode mudar, então uma tupla assim não é &lt;tt class="docutils literal"&gt;hashable&lt;/tt&gt;. Para ser usada como chave para um &lt;tt class="docutils literal"&gt;dict&lt;/tt&gt; ou elemento de um &lt;tt class="docutils literal"&gt;set&lt;/tt&gt;, a tupla precisa ser constituída apenas de objetos &lt;tt class="docutils literal"&gt;hashable&lt;/tt&gt;. Nossas tuplas de nome &lt;tt class="docutils literal"&gt;dum&lt;/tt&gt; e &lt;tt class="docutils literal"&gt;dee&lt;/tt&gt; não são &lt;tt class="docutils literal"&gt;hashable&lt;/tt&gt; porque cada elemento contem uma referência a uma lista, e listas não são &lt;tt class="docutils literal"&gt;hashable&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Agora vamos nos concentrar nos comandos de atribuição que são o coração de todo esse exercício.&lt;/p&gt;
&lt;p&gt;A atribuição em Python nunca copia valores. Ela apenas copia referências. Então quando escrevi &lt;tt class="docutils literal"&gt;skills = t_doom[1]&lt;/tt&gt;, não copiei a lista referenciada por &lt;tt class="docutils literal"&gt;t_doom[1]&lt;/tt&gt;, apenas copiei a referência a ela, que então usei para alterar a lista executando &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;skills.append('rap')&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Voltando ao MIT, a Profa. Stein falava sobre atribuição de uma forma muito cuidadosa. Por exemplo, ao falar sobre um objeto gangorra em uma simulação, ela dizia: “A variável &lt;tt class="docutils literal"&gt;g&lt;/tt&gt; é atribuída à gangorra“, mas nunca “A gangorra é atribuída à variável &lt;tt class="docutils literal"&gt;g&lt;/tt&gt; “. Em se tratando de variáveis de referência, é mais coerente dizer que a variável é atribuída ao objeto, e não o contrário. Afinal, o objeto é criado antes da atribuição.&lt;/p&gt;
&lt;p&gt;Em uma atribuição como &lt;tt class="docutils literal"&gt;y = x * 10&lt;/tt&gt;, o lado direito é computado primeiro. Isto cria um novo objeto ou retorna um já existente. Somente após o objeto ser computado ou retornado, o nome é atribuído a ele.&lt;/p&gt;
&lt;p&gt;Eis uma prova disso. Primeiro criamos uma classe &lt;tt class="docutils literal"&gt;Gizmo&lt;/tt&gt;, e uma instância dela:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Gizmo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;         &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Gizmo id: &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Gizmo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;Gizmo&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4328764080&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Observe que o método &lt;tt class="docutils literal"&gt;__init__&lt;/tt&gt; mostra a identidade do objeto tão logo criado. Isso será importante na próxima demonstração.&lt;/p&gt;
&lt;p&gt;Agora vamos instanciar outro &lt;tt class="docutils literal"&gt;Gizmo&lt;/tt&gt; e imediatamente tentar executar uma operação com ele antes de atribuir um nome ao resultado:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Gizmo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;Gizmo&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4328764360&lt;/span&gt;
&lt;span class="n"&gt;Traceback&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;most&lt;/span&gt; &lt;span class="n"&gt;recent&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="ne"&gt;TypeError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;unsupported&lt;/span&gt; &lt;span class="n"&gt;operand&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Gizmo&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;int&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;y&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;globals&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Este trecho mostra que o novo objeto foi instanciado (sua identidade é &lt;tt class="docutils literal"&gt;4328764360&lt;/tt&gt;) mas antes que o nome &lt;tt class="docutils literal"&gt;y&lt;/tt&gt; possa ser criado, uma exceção &lt;tt class="docutils literal"&gt;TypeError&lt;/tt&gt; abortou a atribuição. A verificação &lt;tt class="docutils literal"&gt;'y' in globals()&lt;/tt&gt; prova que não existe o nome global &lt;tt class="docutils literal"&gt;y&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Para fechar: sempre leia lado direito de uma atribuição primero. Ali o objeto é computado ou retornado. Depois disso, o nome no lado esquerdo é vinculado ao objeto, como uma etiqueta afixada nele. Apenas esqueça aquela idéia de variáveis como caixas.&lt;/p&gt;
&lt;p&gt;Em relação a tuplas, certifique-se que elas apenas contenham referências a objetos imutáveis antes de tentar usá-las como chaves em um dicionário ou itens em um &lt;tt class="docutils literal"&gt;set&lt;/tt&gt;.&lt;/p&gt;
&lt;blockquote&gt;
Este texto foi originalmente publicado no &lt;a class="reference external" href="http://radar.oreilly.com/2014/10/python-tuples-immutable-but-potentially-changing.html"&gt;blog&lt;/a&gt; da editora O'Reilly em inglês. A tradução para o português foi feita por Paulo Henrique Rodrigues Pinheiro. O conteúto é baseado no capítulo 8 do meu livro &lt;a class="reference external" href="http://shop.oreilly.com/product/0636920032519.do"&gt;Fluent Python&lt;/a&gt;. Esse capítulo, intitulado &lt;em&gt;Object references, mutability and recycling&lt;/em&gt; também aborda a semântica da passagem de parâmetros para funções, melhores práticas para manipulação de parâmetros mutáveis, cópias rasas (&lt;em&gt;shallow copies&lt;/em&gt;) e cópias profundas (&lt;em&gt;deep copies&lt;/em&gt;), e o conceito de referências fracas (&lt;em&gt;weak references&lt;/em&gt;) - além de outros tópicos. O livro foca em Python 3 mas grande parte de seu conteúdo se aplica a Python 2.7, como tudo neste texto.&lt;/blockquote&gt;
</summary><category term="python"></category><category term="tuplas"></category></entry></feed>